下面介绍几个分布式ID生成算法。



**SnowFlake算法**



1）算法说明

```
+--------------------------------------------------------------------------+
| 1 Bit Unused | 41 Bit Timestamp |  10 Bit NodeId  |   12 Bit Sequence Id 
|+-------------------------------------------------------------------------+
```

- 最高位是符号位，始终为0，不可用。

- 41位的时间序列，精确到毫秒级，41位的长度可以使用69年。时间位还有一个很重要的作用是可以根据时间进行排序。

- 10位的机器标识，10位的长度最多支持部署1024个节点。

- 12位的计数序列号，序列号即一系列的自增ID，可以支持同一节点同一毫秒生成多个ID序号，12位的计数序列号支持每个节点每毫秒产生4096个ID序号。



2）算法总结

优点：

- 完全是一个无状态机，无网络调用，高效可靠。

缺点：

- 依赖机器时钟，如果时钟错误比如时钟回拨，可能会产生重复Id。
- 容量存在局限性，41位的长度可以使用69年，一般够用。
- 并发局限性，每毫秒单机最大产生4096个Id。
- 只适用于int64类型的Id分配，int32位Id无法使用。



3）适用场景

一般的非Web应用程序的int64类型的Id都可以使用。

> 为什么说非Web应用，Web应用为什么不可以用呢，因为JavaScript支持的最大整型就是53位，超过这个位数，JavaScript将丢失精度。



**RainDrop算法**



1）算法说明

为了解决JavaScript丢失精度问题，由Snowflake算法改造而来的53位的分布式Id生成算法。

```
+--------------------------------------------------------------------------+
| 11 Bit Unused | 32 Bit Timestamp |  7 Bit NodeId  |   14 Bit Sequence Id 
|+--------------------------------------------------------------------------+
```



- 最高11位是符号位，始终为0，不可用，解决JavaScript的精度丢失。

- 32位的时间序列，精确到秒级，32位的长度可以使用136年。

- 7位的机器标识，7位的长度最多支持部署128个节点。

- 14位的计数序列号，序列号即一系列的自增Id，可以支持同一节点同一秒生成多个Id，14位的计数序列号支持每个节点每秒单机产生16384个Id。



2）算法总结

优点：

- 完全是一个无状态机，无网络调用，高效可靠。

缺点：

- 依赖机器时钟，如果时钟错误比如时钟不同步、时钟回拨，会产生重复Id。
- 容量存在局限性，32位的长度可以使用136年，一般够用。
- 并发局限性，低于snowflake。
- 只适用于int64类型的Id分配，int32位Id无法使用。



3）适用场景

一般的Web应用程序的int64类型的Id都基本够用。



**分区独立分配算法**



1）算法说明

通过将Id分段分配给不同单元独立管理。同一个单元的不同机器再通过共享redis进行单元内的集中分配。

相当于每个单元预先分配了一批Id，然后再由各个单元内进行集中式分配。

比如int32的范围从-2147483648到2147483647，Id使用范围[1,2100000000)，前两位表示region，则每个region支持100000000（一亿）个资源，即Id组成格式可以表示为[0-20] [0-99999999]。



即int32位可以支持20个单元，每个单元支持一亿个Id。



![图片](..\images\fen_qu_du_li_fen_pei_suan_fa.jpg)







2）算法总结

优点：

- 区域之间无状态，无网络调用，具备可靠唯一性

缺点：

- 分区容量存在局限性，需要预先评估业务容量。
- 从Id中无法判断生成的先后顺序。



3）适用场景

适用于int32类型的Id分配，单个区域内容量上限可评估的业务使用。



**集中式分配算法**



1）算法说明

集中式可以是Redis，也可以是ZooKeeper，也可以利用数据库的自增Id集中分配。

2）算法总结

优点：

- 全局递增
- 可靠的唯一性Id
- 无容量和并发量限制

缺点：

- 增加了系统复杂性，需要强依赖中心服务。



3）适用场景

具备可靠的中心服务的场景可以选用，其他int32类型无法使用分区独立分配的业务场景。



**总结**



每一种分配算法都有各自的适用场景，需要根据业务需求选择合适的分配算法。主要需要考虑几个因素：

- Id类型是int64还是int32。
- 业务容量以及并发量需求。
- 是否需要与JavaScript交互。



**引用**

[多中心容灾实践：如何实现真正的异地多活？](https://mp.weixin.qq.com/s/ty5GltO9M648OXSWgLe_Sg)